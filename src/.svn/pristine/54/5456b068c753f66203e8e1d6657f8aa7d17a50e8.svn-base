/**
 * ServerThread class for the Server of the minigame game. Takes an incoming connection and creates a new thread.
 *
 * @author Connor Wilkes
 * @version 1/3/2018
 */

package Server;

import Login.User;

import java.io.*;
import java.net.Socket;
import java.util.Date;
import java.util.concurrent.Callable;
import java.util.logging.Level;
import java.util.logging.Logger;


public class ServerThread implements Callable<Void> {

    private Socket connection;
    private User connectedUser;
    private InputStream in;
    private OutputStream out;
    private final static Logger auditLogger = Logger.getLogger("requests");
    private final static Logger errorLogger = Logger.getLogger("errors");

    /**
     * Constructor for testing purposes
     * @param connection Socket associated with the Thread
     */
    public ServerThread(Socket connection) {
        this.connection = connection;
    }

    /**
     * Constructor for the ServerThread class
     * @param connection Socket associated with the Thread
     * @param connectedUser User associated with the connection
     */
    public ServerThread(Socket connection, User connectedUser) {
        this.connection = connection;
        this.connectedUser = connectedUser;
    }

    /**
     * Run method for the thread
     * @return null
     */
    @Override
    public Void call() {
        try {
            auditLogger.info("Connected to: " + connection.getRemoteSocketAddress() + " on " + new Date());
            in = connection.getInputStream();
            out = connection.getOutputStream();
            ObjectInputStream objectIn = new ObjectInputStream(in);
            Writer writerOut = new OutputStreamWriter(out);
            User toSet = (User) objectIn.readObject();
            this.connectedUser = toSet;
            System.out.println(connectedUser.getUsername());
        } catch (IOException ex) {
            System.err.println(ex);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } finally {
            try {
                connection.close();
            } catch (IOException e) {

            }
        }
        return null;
    }

    /**
     * Helper function to close the server
     * @param socket socket to close
     */
    public static void closeSilently(Socket socket) {
        if (socket != null) {
            try {
                socket.close();
            } catch (IOException ex) {
                errorLogger.log(Level.SEVERE, "could not close connection", ex);
            }
        }
    }
}

